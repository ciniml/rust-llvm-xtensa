#define DEBUG_TYPE "mccodeemitter"
#include "MCTargetDesc/XtensaMCTargetDesc.h"
#include "MCTargetDesc/XtensaMCFixups.h"
#include "llvm/MC/MCCodeEmitter.h"
#include "llvm/MC/MCContext.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCInstrInfo.h"
#include "llvm/MC/MCRegisterInfo.h"

using namespace llvm;

namespace 
{
class XtensaMCCodeEmitter : public MCCodeEmitter 
{
  const MCInstrInfo &MCII;
  MCContext &Ctx;

public:
  XtensaMCCodeEmitter(const MCInstrInfo &mcii, MCContext &ctx)
    : MCII(mcii), Ctx(ctx) 
  {
  }

  ~XtensaMCCodeEmitter() {}

  // OVerride MCCodeEmitter.
  void encodeInstruction(const MCInst &MI, raw_ostream &OS,
                         SmallVectorImpl<MCFixup> &Fixups,
                         const MCSubtargetInfo &STI) const override;

private:
  // Automatically generated by TableGen.
  uint64_t getBinaryCodeForInstr(const MCInst &MI,
                                 SmallVectorImpl<MCFixup> &Fixups,
                                 const MCSubtargetInfo &STI) const;

  // Called by the TableGen code to get the binary encoding of operand
  // MO in MI.  Fixups is the list of fixups against MI.
  unsigned getMachineOpValue(const MCInst &MI, const MCOperand &MO,
                             SmallVectorImpl<MCFixup> &Fixups,
                             const MCSubtargetInfo &STI) const;

  //Xtensa
  unsigned getJumpTargetEncoding(const MCInst &MI, unsigned int OpNum,
                                 SmallVectorImpl<MCFixup> &Fixups,
                                 const MCSubtargetInfo &STI) const 
  {
    const MCOperand &MO = MI.getOperand(OpNum);
    //TODO: do we need to sign extend explicitly?
    if (MO.isImm())
      return MO.getImm() << 1;
    llvm_unreachable("Jump with no immediate field");
  }

  unsigned getBranchTargetEncoding(const MCInst &MI, unsigned int OpNum,
                                   SmallVectorImpl<MCFixup> &Fixups,
                                   const MCSubtargetInfo &STI) const 
  {
    const MCOperand &MO = MI.getOperand(OpNum);
    //TODO: do we need to sign extend explicitly?
    if (MO.isImm())
      return MO.getImm() << 1;
    // Branch target is expr add fixup
    Fixups.push_back(MCFixup::create(0, MO.getExpr(),
          (MCFixupKind)Xtensa::fixup_xtensa_brlo));
    Fixups.push_back(MCFixup::create(0, MO.getExpr(),
          (MCFixupKind)Xtensa::fixup_xtensa_brhi));
    return 0;
  }

  unsigned getPCImmEncoding(const MCInst &MI, unsigned int OpNum,
                            SmallVectorImpl<MCFixup> &Fixups,
                            const MCSubtargetInfo &STI) const 
  {
    const MCOperand &MO = MI.getOperand(OpNum);
    //TODO: do we need to sign extend explicitly?
    if (MO.isImm())
      return MO.getImm();
    llvm_unreachable("Branch with no immediate field");
  }

  unsigned getPCImm64Encoding(const MCInst &MI, unsigned int OpNum,
                              SmallVectorImpl<MCFixup> &Fixups,
                              const MCSubtargetInfo &STI) const 
  {
    const MCOperand &MO = MI.getOperand(OpNum);
    //TODO: do we need to sign extend explicitly?
    if (MO.isImm())
      return MO.getImm() << 12;
    llvm_unreachable("Branch with no immediate field");
  }

  // Operand OpNum of MI needs a PC-relative fixup of kind Kind at
  // Offset bytes from the start of MI.  Add the fixup to Fixups
  // and return the in-place addend, which since we're a RELA target
  // is always 0.
  unsigned getPCRelEncoding(const MCInst &MI, unsigned int OpNum,
                            SmallVectorImpl<MCFixup> &Fixups,
                            unsigned Kind, int64_t Offset) const;

  unsigned getCallEncoding(const MCInst &MI, unsigned int OpNum,
                               SmallVectorImpl<MCFixup> &Fixups, 
                               const MCSubtargetInfo &STI) const 
  {
    return getPCRelEncoding(MI, OpNum, Fixups, Xtensa::fixup_xtensa_call, 0);
  }
};
}

MCCodeEmitter *llvm::createXtensaMCCodeEmitter(const MCInstrInfo &MCII,
                                                const MCRegisterInfo &MRI,
                                                MCContext &Ctx) 
{
  return new XtensaMCCodeEmitter(MCII, Ctx);
}

void XtensaMCCodeEmitter::encodeInstruction(const MCInst &MI, raw_ostream &OS,
                                           SmallVectorImpl<MCFixup> &Fixups,
                                           const MCSubtargetInfo &STI) const 
{
  uint64_t Bits = getBinaryCodeForInstr(MI, Fixups, STI);
  unsigned Size = MCII.get(MI.getOpcode()).getSize();
  // Little-endian insertion of Size bytes.
  unsigned ShiftValue = 0;
  for (unsigned I = 0; I != Size; ++I) {
    OS << uint8_t(Bits >> ShiftValue);
    ShiftValue += 8;
  }
}

unsigned
XtensaMCCodeEmitter::getMachineOpValue(const MCInst &MI, const MCOperand &MO,
                                      SmallVectorImpl<MCFixup> &Fixups,
                                      const MCSubtargetInfo &STI) const 
{
  if (MO.isReg())
    return Ctx.getRegisterInfo()->getEncodingValue(MO.getReg());
  if (MO.isImm())
    return static_cast<unsigned>(MO.getImm());
  llvm_unreachable("Unexpected operand type!");
}

unsigned
XtensaMCCodeEmitter::getPCRelEncoding(const MCInst &MI, unsigned int OpNum,
                                       SmallVectorImpl<MCFixup> &Fixups,
                                       unsigned Kind, int64_t Offset) const 
{
  const MCOperand &MO = MI.getOperand(OpNum);
  // For compatibility with the GNU assembler, treat constant operands as
  // unadjusted PC-relative offsets.
  if (MO.isImm())
    return MO.getImm() / 2;

  const MCExpr *Expr = MO.getExpr();
  if (Offset) {
    // The operand value is relative to the start of MI, but the fixup
    // is relative to the operand field itself, which is Offset bytes
    // into MI.  Add Offset to the relocation value to cancel out
    // this difference.
    const MCExpr *OffsetExpr = MCConstantExpr::create(Offset, Ctx);
    Expr = MCBinaryExpr::createAdd(Expr, OffsetExpr, Ctx);
  }
  Fixups.push_back(MCFixup::create(Offset, Expr, (MCFixupKind)Kind));
  return 0;
}

#include "XtensaGenMCCodeEmitter.inc"
